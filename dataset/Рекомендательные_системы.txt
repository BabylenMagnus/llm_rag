Рекомендательные системы
Рекомендательные системы — программы, которые пытаются предсказать, какие объекты будут интересны пользователю, имея определенную информацию о его профиле.
Содержание
- 1 Обзор и постановка задачи
- 2 Кластеризация пользователей
- 3 Холодный старт
- 4 User-based и item-based алгоритмы
- 5 Алгоритм SVD
- 6 Решение проблемы матрицы оценок
- 7 Численная оптимизация
- 8 Измерение качества рекомендаций
- 9 См. также
- 10 Примечания
- 11 Источники информации
Обзор и постановка задачи
Основная задача рекомендательных систем[1] — проинформировать пользователя о товарах или услугах, которые будут для него наиболее интересными и актуальными. Разнообразие таких систем можно проиллюстрировать основными характеристиками:
- предмет рекомендации;
- цель рекомендации;
- контекст рекомендации;
- источник рекомендации;
- степень персонализации;
- формат рекомендации;
- прозрачность рекомендации.
В центре таких систем лежит матрица предпочтений. В этой матрице одна из осей отвечает за пользователей, вторая за объекты рекомендации. Заполнена же эта матрица значениями по заданной шкале (например отдо ). Так как каждый пользователь обычно может оценить только небольшую часть объектов, то данная матрица очень разрежена. Задача системы — обобщение информации и предсказание отношения пользователя к объекту (заполнение пропущенных значений матрицы).
Данные, сообщающие предпочтения пользователя, можно получить двумя способами:
- явно (англ. explicit feedback, explicit ratings);
- неявно (англ. implicit feedback, implicit ratings).
При явном оценивании пользователь сам показывает, насколько ему интересен тот или иной объект. Типичным примером данных, полученных при явном оценивании, являются рейтинги, проставленные пользователями объектам. На практике таких данных обычно мало. Гораздо больше имеется информации о неявных предпочтениях пользователя: просмотры, клики, добавления в закладки. Однако по таким данным не всегда можно сделать явный вывод об отношении пользователя к объекту. Например, если пользователь посмотрел фильм, то это означает, что до просмотра он ему был интересен, но сделать вывод о том, понравился ли ему фильм, нельзя. В большинстве рекомендательных систем эти два подхода используются вместе, тем самым минимизируются недостатки каждого из них в отдельности.
Формализуем задачу. Имеется множество пользователей, множество объектов и множество событий (действия, которые совершают пользователи с объектами). Каждое событие задается пользователем , объектом , своим результатом и, возможно, но не обязательно, другими характеристиками. По итогу от рекомендательной системы требуется:
- предсказывать предпочтение пользователя к объекту :
- выдавать персональные рекомендации для пользователя :
- определять объекты, похожие на объект :
Кластеризация пользователей
|Определение:
|Коллаборативная фильтрация (англ. collaborative filtering) — один из методов построения прогнозов (рекомендаций) в рекомендательных системах, использующий известные предпочтения (оценки) группы пользователей для прогнозирования неизвестных предпочтений другого пользователя.
Основная идея метода — похожим пользователям нравятся похожие объекты.
Алгоритм можно разбить на следующие шаги:
- Выбор условной меры схожести пользователей по истории их оценок .
- Объединение пользователей в группы (кластеры) так, чтобы похожие пользователи оказывались в одном кластере .
- Предсказание оценки пользователя: средняя оценка кластера этому объекту .
Проблемы алгоритма:
- нечего рекомендовать новым пользователям, так как их невозможно отнести к какому-либо кластеру;
- не учитывается контекст и специфика пользователя;
- если в кластере нет оценки объекта, то предсказание невозможно.
Холодный старт
|Определение:
|Холодный старт (англ. cold start) — ситуация, когда ещё не накоплено достаточное количество данных для корректной работы рекомендательной системы.
Данная проблема актуальна для новых объектов или объектов, с которыми пользователи редко совершают действия. Если средний рейтинг посчитан по оценкам всего трёх пользователей, такая оценка явно не будет достоверной, и пользователи это понимают. Часто в таких ситуациях рейтинги искусственно корректируют.
Первый способ. Предлагается показывать не среднее значение, а сглаженное среднее (англ. damped mean). Смысл таков: при малом количестве оценок отображаемый рейтинг больше тяготеет к некому безопасному «среднему» показателю, а как только набирается достаточное количество новых оценок, «усредняющая» корректировка перестает действовать.
Второй способ. Для объекта считается средний рейтинг, затем определяется доверительный интервал(англ. сonfidence interval) этого рейтинга. Математически, чем больше оценок, тем меньше вариация среднего и, значит, больше уверенность в его корректности. А в качестве рейтинга объекта можно выводить, например, нижнюю границу интервала (англ. low CI bound). При этом понятно, что такая система будет достаточно консервативной, с тенденцией к занижению оценок по новым объектам.
User-based и item-based алгоритмы
User-based алгоритм
Заменим жесткую кластеризацию на предположение, что объект понравится пользователю, если он понравился похожим пользователям. Тогда предпочтение пользователяк объекту можно записать следующим образом:
, где — средняя оценка, проставленная пользователем , а — мера схожести пользователей и .
Однако у этого алгоритма есть недостатки:
- холодный старт — новые объекты никому не рекомендуются;
- нечего рекомендовать новым/нетипичным пользователям.
Item-based алгоритм
Также имеется абсолютно симметричный алгоритм. Теперь будем считать, что объект понравится пользователю, если ему понравились похожие объекты. Предпочтение пользователяк объекту запишется так:
, где — средняя оценка, проставленная объекту , а — мера схожести объектов и .
У такого подхода остается недостаток в виде холодного старта и при этом рекомендации становятся тривиальными.
Cтоит отметить, что ресурсоемкость вычислений такими методами высока: для предсказаний необходимо держать в памяти все оценки всех пользователей.
Алгоритм SVD
Попробуем воспользоваться сингулярным разложением (SVD) для задачи рекомендации.
Разложим матрицу оценокс использованием сингулярного разложения: . Применяя усеченное разложение, получим следующее: . Из свойств сингулярного разложения мы знаем, что матрица является наилучшим низкоранговым приближением с точки зрения средне-квадратичного отклонения. Несколько упростим запись выражения: запишем произведение первых двух матриц , а матрицу обозначим как . Получим формулу . Интерпретировать полученную формулу стоит следующим образом: приближенная матрица оценок может быть вычислена как произведение усеченных матриц пользователей и оценок.
Благодаря использованию такого усечения можно решить одну из главных проблем всех ранее упомянутых алгоритмов: ресурсоемкость вычислений.
Чтобы предсказать оценку пользователядля объекта , берём некоторый вектор для данного пользователя и вектор данного объекта . Получаем необходимое предсказание: .
Помимо предсказания оценок, алгоритм позволяет выявлять скрытые признаки объектов и интересы пользователей. Например, может так получиться, что на первой координате вектора у каждого пользователя будет стоять число, показывающее, похож ли пользователь больше на мальчика или на девочку, на второй координате — число, отражающее примерный возраст пользователя. У фильма же первая координата будет показывать, интересен ли он больше мальчикам или девочкам, а вторая — какой возрастной группе пользователей он интересен.
Однако данный алгоритм имеет ряд проблем:
- матрица оценок полностью не известна, поэтому просто взять SVD разложение не представляется возможным;
- Сингулярное разложение не единственное, поэтому даже если какое-то разложение будет найдено, нет гарантии, что первая координата в нем будет соответствовать некоторым выбранным характеристикам пользователя.
Решение проблемы матрицы оценок
Для решения проблем, связанных с матрицей оценок, построим модель.
Модель будет зависеть от следующих параметров: вектор пользователей и вектор объектов. Для заданных параметрови возьмем вектор пользователя и вектор объекта , затем для предсказания оценки получим их скалярное произведение, как и в алгоритме SVD: , где .
Но вектора пока не известны, их нужно получить. Имеются оценки пользователей, при помощи которых можно найти оптимальные параметры, при которых модель предскажет оценки наилучшим образом:.
То есть, нужно найти такие параметры регуляризацией. В качестве регуляризатора будет выступать слагаемое . Получим следующее: ., чтобы квадрат ошибки был наименьшим. Однако ситуация следующая: оптимизация приведет к наименьшим ошибкам в будущем, но как именно оценки будут спрашивать — неизвестно. Следовательно, это нельзя оптимизировать. Однако, так как оценки, уже проставленные пользователями, известны, постараемся минимизировать ошибку на тех данных, что у нас уже есть. Также воспользуемся
Численная оптимизация
Чтобы найти оптимальные параметры построенной модели необходимо оптимизировать следующий функционал:
.
Множество параметров: для каждого объекта и пользователя есть свой вектор, который нужно оптимизировать. Чтобы найти минимум функции можно использовать метод градиентного спуска. Для этого нам понадобится градиент — вектор из частных производных по каждому параметру, который в нашем случае будет выглядеть так:
.
Шаг градиентного спуска можно записать следующим образом:, где — коэффициент скорости обучения.
Измерение качества рекомендаций
Зачастую качество рекомендаций измеряется с помощью функции ошибки RMSE:
.
Данный способ, хоть и является стандартным для измерением качества, имеет ряд недостатков:
- пользователи с большим разбросом оценок будут влиять на значение метрики больше, чем остальные;
- ошибка в предсказании высокой оценки имеет такой же вес, что и ошибка в предсказании низкой оценки;
- есть риск плохого ранжирования при почти идеальной RMSE и наоборот.
Существуют при этом и другие метрики — метрики ранжирования, на основе полноты и точности. Однако они не так популярны и используются значительно реже.
См. также
- Кластеризация
- Регуляризация
- Оценка качества в задаче кластеризации
- Оценка качества в задачах классификации и регрессии