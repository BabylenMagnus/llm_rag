Кросс-валидация
Кросс-валидация или скользящий контроль — процедура эмпирического оценивания обобщающей способности алгоритмов. С помощью кросс-валидации эмулируется наличие тестовой выборки, которая не участвует в обучении, но для которой известны правильные ответы.
Содержание
- 1 Определения и обозначения
- 2 Разновидности кросс-валидации
- 2.1 Валидация на отложенных данных (Hold-Out Validation)
- 2.2 Полная кросс-валидация (Complete cross-validation)
- 2.3 k-fold кросс-валидация
- 2.4 t)k-fold кросс-валидация
- 2.5 Кросс-валидация по отдельным объектам (Leave-One-Out)
- 2.6 Случайные разбиения (Random subsampling)
- 2.7 Критерий целостности модели (Model consistency criterion)
- 3 См. также
- 4 Примечания
- 5 Источники информации
Определения и обозначения
Пусть признаков, описывающих объекты, а — конечное множество меток.— множество
— обучающая выборка,
— мера качества,
— алгоритм обучения.
Разновидности кросс-валидации
Валидация на отложенных данных (Hold-Out Validation)
Обучающая выборка один раз случайным образом разбивается на две части
После чего решается задача оптимизации:
,
Метод Hold-out применяется в случаях больших датасетов, т.к. требует меньше вычислительных мощностей по сравнению с другими методами кросс-валидации. Недостатком метода является то, что оценка существенно зависит от разбиения, тогда как желательно, чтобы она характеризовала только алгоритм обучения.
Полная кросс-валидация (Complete cross-validation)
- Выбирается значение ;
- Выборка разбивается всеми возможными способами на две части .
,
Здесь число разбиенийстановится слишком большим даже при сравнительно малых значениях t, что затрудняет практическое применение данного метода.
k-fold кросс-валидация
- Обучающая выборка разбивается на непересекающихся одинаковых по объему частей;
- Производится
итераций. На каждой итерации происходит следующее:
- Модель обучается на части обучающей выборки;
- Модель тестируется на части обучающей выборки, которая не участвовала в обучении.
Каждая изчастей единожды используется для тестирования. Как правило, (5 в случае малого размера выборки).
.
# Пример кода для k-fold кросс-валидации: # Пример классификатора, cпособного проводить различие между всего лишь двумя # классами, "пятерка" и "не пятерка" из набор данных MNIST import numpy as np from sklearn.model_selection import StratifiedKFold from sklearn.datasets import fetch_openml from sklearn.base import clone from sklearn.linear_model import SGDClassifier mnist = fetch_openml('mnist_784', version=1) X, y = mnist["data"], mnist["target"] y = y.astype(np.uint8) X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:] y_train_5 = (y_train == 5) # True для всех пятерок, False для всех остальных цифр. Задача опознать пятерки y_test_5 = (y_test == 5) sgd_clf = SGDClassifier(random_state=42) # классификатор на основе метода стохастического градиентного спуска (Stochastic Gradient Descent SGD) # Разбиваем обучающий набора на 3 блока # выработку прогнозов и их оценку осуществляем на каждом блоке с использованием модели, обученной на остальных блоках</font> skfolds = StratifiedKFold(n_splits=3, random_state=42) for train_index, test_index in skfolds.split(X_train, y_train_5): clone_clf = clone(sgd_clf) X_train_folds = X_train[train_index] y_train_folds = y_train_5[train_index] X_test_fold = X_train[test_index] y_test_fold = y_train_5[test_index] clone_clf.fit(X_train_folds, y_train_folds) y_pred = clone_clf.predict(X_test_fold) n_correct = sum(y_pred == y_test_fold) print(n_correct / len(y_pred)) # print 0.95035 # 0.96035 # 0.9604
t)k-fold кросс-валидация
- Процедура выполняется
раз:
- Обучающая выборка случайным образом разбивается на непересекающихся одинаковых по объему частей;
- Производится
итераций. На каждой итерации происходит следующее:
- Модель обучается на части обучающей выборки;
- Модель тестируется на части обучающей выборки, которая не участвовала в обучении.
,
.
Кросс-валидация по отдельным объектам (Leave-One-Out)
Выборка разбивается наи 1 объект раз.
, где .
Преимущества LOO в том, что каждый объект ровно один раз участвует в контроле, а длина обучающих подвыборок лишь на единицу меньше длины полной выборки.
Недостатком LOO является большая ресурсоёмкость, так как обучаться приходитсяраз. Некоторые методы обучения позволяют достаточно быстро перенастраивать внутренние параметры алгоритма при замене одного обучающего объекта другим. В этих случаях вычисление LOO удаётся заметно ускорить.
Случайные разбиения (Random subsampling)
Выборка разбивается в случайной пропорции. Процедура повторяется несколько раз.
Критерий целостности модели (Model consistency criterion)
Не переобученый алгоритм должен показывать одинаковую эффективность на каждой части.
,
Метод может быть обобщен как аналог.
См. также
Примечания
Источники информации
- Скользящий контроль - статья на MachineLearning.ru
- Model assessment and selection