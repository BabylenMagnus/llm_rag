Настройка глубокой сети
Глубокая сеть состоит из нескольких слоев, где каждый слой организован таким образом, что каждый нейрон в одном слое получает свою копию всех выходных данных предыдущего слоя. Эта модель идеально подходит для определенных типов задач, например, обучение на ограниченном количестве более или менее неструктурированных параметров. Существует множество способов изменения параметров (весов) в такой модели, когда ей на вход поступают необработанные данные.
Содержание
Инициализация сети
Принцип выбора начальных значений параметров для слоев, составляющих модель очень важен: установка всех параметров в 0 будет серьезным препятствием для обучения, так как ни один из параметров изначально не будет активен. Присваивать параметрам значения из интервала инициализации сети может зависеть, достигнет она высочайшей производительности или вообще не будет сходиться. Даже если задача не предполагает такой крайности, удачно выбранный способ инициализации начальных параметров может значительно влиять на способность модели к обучению, так как он предустанавливает параметры модели с учетом функции потерь[1].— тоже обычно не лучший вариант — на самом деле, иногда (в зависимости от задачи и сложности модели) от правильной
Всегда можно выбрать случайно начальное приближение, но лучше выбирать определённым образом, ниже приведены самые распространённые из них:
- Метод инициализации Завьера (Xavier) (иногда — метод Glorot’а)[2]. Основная идея этого метода — упростить прохождение сигнала через слой во время как прямого, так и обратного распространения ошибки для линейной функции активации (этот метод также хорошо работает для сигмоидной функции, так как участок, где она ненасыщена, также имеет линейный характер). При вычислении параметров этот метод опирается на вероятностное распределение (равномерное или нормальное) с дисперсией, равной , где и — количества нейронов в предыдущем и последующем слоях соответственно;
- Метод инициализации Ге (He) — вариация метода Завьера, больше подходящая функции активации ReLU, компенсирующая тот факт, что эта функция возвращает нуль для половины области определения. А именно, в этом случае [3].
Граф вычислений
Глубокие сети являются особенной формой графа вычислений.
Граф вычислений — ориентированный граф, узлы которого соответствуют операциям или переменным. Переменные могут передавать свое значение в операции, а операции могут передавать свои результаты в другие операции. Таким образом, каждый узел в графе определяет функцию переменных.
Значения, которые вводятся в узлы и выходят из узлов, называются тензорами (т.е. многомерными массивами). На рисунке 1 представлен граф вычислений для функции. В нейронах сетях функций имеют больше аргументов и сложнее, но смысл операций остаётся прежним.
Процесс передачи значений от входных нейронов к выходным называется прямым распространением (от англ. Forward pass). После чего мы вычисляем ошибку обработанных сетью данных на выходном нейроне и, основываясь на её значении, делаем обратную передачу ошибки (Back propagation). Обратное распространение ошибки заключается в том, чтобы последовательно менять параметры нейронной сети, начиная с параметров выходного нейрона. Значения параметров будут меняться в сторону уменьшения ошибки.
Преимуществом такого представления функции является простота вычисления производных. Используя следующие правила вычисления частных производных:
- ;
- ;
- .
Рассмотрим граф вычислений на рисунке 2 с поданными на вход значениями. Подсчёт производных по графу вычислений производим от значения функции к значениям независимых переменных-входов.
- ;
- , ;
- , .
Граф вычислений является частью нейронной сети, у которой — входные значения, — выходные с сети значения, — матрица параметров, приводящая значения предыдущего слоя к выходным значениям.
Зная производные, можно искать матрицы параметров градиентного спуска сдвигаемся в сторону градиента (при максимизации) или обратную ему (при минимизации) , где — функция потерь, а — параметры после -ой итерации, или его модификаций[4].(числа, на которые умножаются входные для этого слоя значения) с помощью
Способы настройки параметров
Ниже представлены различные вариации градиентного спуска (более подробное сравнение, применительно к данной задаче [7]). Градиентный спуск — итеративный алгоритм поиска минимума или максимума функции, метриками качества алгоритма этого семейства методов являются скорость сходимости и сходимость в глобальный оптимум. Методы имеют различные преимущества на различных функциях. Так например на рисунке 3 из локального минимума метод adam и метод Нестерова не могут достигнуть глобального, а в случае "шаткого" ландшафта (рисунок 4) эти методы сходятся быстрее.
- Метод стохастического градиентного спуска заключается в том, что алгоритм делает шаг постоянной величины в направлении, указанном градиентом в текущей точке: ;
- Модификация Momentum [8] запоминает скорость на предыдущем шаге и добавляет в раз меньшую величину на следующем шаге: , ;
- Метод Нестерова (англ. Nesterov accelerated gradient, NAG)[9] добавляет к методу Momentum идею "заглядывания вперёд", используя производную не в текущей точке, а в следующей (если бы мы продолжали двигаться в этом же направлении без измений): ;
- Adagrad имеет преимущество в плане обучения нейронных сетей в предположении, что процесс обучения должен сходится (т.е. не нужно сильно менять параметры сети, когда мы уже немного научились). В процессе обучения после каждого прецендента алгоритм будет уменьшать шаг за счёт суммы квадратов координат градиента предыдущих итераций[10]: , где — диагональная матрица, элементы которой, суммы квадратов координат градиента к -ой итерации алгоритма: ;
- RMSProp[11] основан на идее Adagrad'a, но с учётом того элементы матрицы могут быть большими величинами и начать препятствовать обучению. Для этого RMSProp делит шаг не на полную сумму градиентов, а на скользящую, т.е. , обновление параметров осталось таким же как в Adagrad : ;
- Adadelta[12] устраняет "нефизичность" методов Adagrad и RMSProp, добавка с градиентом в которых не имеет размерности параметров(точнее вообще безразмерна). Умножение этого слагаемого на любую величину правильной размерности — не самая хорошая идея. Используем разложение ряда Тейлора в точке с большим числом членов, тогда появится матрица вторых производных функции потерь: , расчёт которой повлечёт за собой дополнительные затраты на её расчёт (сами градиенты мы получаем сразу при обратном распространении ошибки), поэтому вместо неё можно брать приближение (из сложных выводов получаем необходимый множитель ), однако в данном случае знание предыдущей скорости не добавляет алгоритму "инерции" методов Momentum и NAG): , где ;
- Adam[13] сочетает в себе преимущества NAG и Adadelta над обычным градиентным спуском: , где и .
Сравнение способов настройки параметров
Рассмотрим график седловой функции с "седлом" в точке. Предположим, что в качестве начальной точки выбрана точка , где . На рисунке координата варьируется в пределах от до , координата , а координата . Рассмотрим работу описанных выше методов, примененных к данной оптимизируемой функции с данной начальной точкой:
- SGD (Стандартный градиентный спуск без оптимизаций) никак не учитывает тот факт, что по координате производная в данной точке пренебрежимо мала по сравнению с производной по . Поэтому через малое число итераций алгоритм сойдется в окрестности седловой точки и остановится, потому что производная в данной точке нулевая.
- Momentum. Так как добавится инерция, то спуск в сторону седловой точки будет значительно быстрее, чем в случае со стандартным градиентным спуском. Однако, оптимизируемая переменная будет еще долго колебаться в плоскости , накапливая градиенты. При этом колебания будут затухать из-за того, что параметр , но т.к. оптимизируемая переменная несколько раз отдалится от точки на достаточное расстояние, успеет накопиться значение производной по координате , достаточное для того чтобы выйти из локального минимума. Однако для этого потребуется большое число итераций, необходимое для того, чтобы производная по перестала преобладать над производной по .
- NAG. Эффект будет схожим с алгоритмом Momentum, однако спуск в плоскости будет происходить быстрее благодаря заглядыванию вперед.
- Adagrad. Изначально спуск будет происходить медленнее, чем при использовании SGD из-за нормирования градиента по всем координатам, однако метод сойдется в глобальном минимуме выбранной области графика.
- RMSProp. Изначально процесс оптимизации почти совпадает с Adagrad, но в области, где функция начинает сильно убывать, благодаря использованию скользящей суммы градиентов (то есть благодаря тому, что мы забываем старые изменения и больше учитываем новые) алгоритм RMSProp оптимизирует переменную быстрее, чем Adagrad.
- Adadelta. Использует все преимущества RMSProp, но при этом в данном случае сходится быстрее в раз.
См.также
- Глубокое обучение
- Инициализация параметров глубокой сети
- Стохастический градиентный спуск
- Обратное распространение ошибки
Примечания
-  Тонкая настройка нейронной сети, Habr
-  Understanding the difficulty of training deep feedforward neural networks
-  Delving Deep into Rectifiers
-  Метод градиентного спуска
-  Методы оптимизации нейронных сетей, Habr
-  Методы оптимизации нейронных сетей, Habr
-  Методы оптимизации нейронных сетей, Habr
-  Momentum, Wikipedia
-  Nesterov accelerated gradient
-  AdaGrad
-  RMSProp
-  Adadelta
-  Adam
Источники информации
- Курс лекций по машинному обучению — Воронцов К.В.
- Riedmiller, M., & Braun, H. (1993). A direct adaptive method for faster backpropagation learning: The RPROP algorithm. In Neural Networks, 1993., IEEE International Conference on (pp. 586-591). IEEE.