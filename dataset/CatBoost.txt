CatBoost
Библиотека CatBoost — метод машинного обучения, основанный на градиентном бустинге (англ. gradient boosting).
Практически любой современный метод на основе градиентного бустинга работает с числовыми признаками. Если у нас в наборе данных присутствуют не только числовые, но и категориальные признаки (англ. categorical features), то необходимо переводить категориальные признаки в числовые. Это приводит к искажению их сути и потенциальному снижению точности работы модели. Именно поэтому было важно разработать алгоритм, который умеет работать не только с числовыми признаками, но и с категориальными напрямую, закономерности между которыми этот алгоритм будет выявлять самостоятельно, без ручной «помощи». CatBoost — библиотека для градиентного бустинга, главным преимуществом которой является то, что она одинаково хорошо работает «из коробки» как с числовыми признаками, так и с категориальными. Программное обеспечение разработано по методологии SCRUM.
Документацию по CatBoost можно найти на сайте[1].
Содержание
- 1 Общий принцип работы
- 2 Особенности CatBoost
- 3 Обучение
- 4 Работа с датасетом
- 5 Подбор параметров
- 6 Полезная функциональность
- 7 Бенчмарки
- 8 Пример использования
- 9 См. также
- 10 Примечания
- 11 Источники информации
Общий принцип работы
Дерево решений
Алгоритм работы следующий: для каждого документа имеется набор значений признаков, имеется дерево, в вершинах дерева — условия. Если условие выполнено, осуществляется переход в правого ребенка вершины, иначе в левого. Нужно пройти до листа по дереву в соответствии со значениями признаков для документа. На выходе каждому документу соответствует значение листа. Это и есть ответ.
Бустинг
Идея бустинг-подхода заключается в комбинации слабых (с невысокой обобщающей способностью) функций, которые строятся в ходе итеративного процесса, где на каждом шаге новая модель обучается с использованием данных об ошибках предыдущих. Результирующая функция представляет собой линейную комбинацию базовых, слабых моделей. Более подробно можно посмотреть в статье про градиентный бустинг[2].
Далее будет рассматриваться бустинг деревьев решений. Будем строить несколько деревьев, чтобы добавление новых деревьев уменьшало ошибку. Итого при достаточно большом количестве деревьев мы сможем сильно уменьшить ошибку, однако не стоит забывать, что чем больше деревьев, тем дольше обучается модель и в какой-то момент прирост качества становится незначительным.
Градиентный бустинг
- В основе CatBoost лежит градиентный бустинг.
- Градиент функции ошибки — все производные по всем значениям функции
Градиентный бустинг — метод машинного обучения, который создает решающую модель прогнозирования в виде ансамбля слабых моделей прогнозирования, обычно деревьев решений. Он строит модель поэтапно, позволяя оптимизировать произвольную дифференцируемую функцию потерь.
Особенности CatBoost
Режимы работы
- Регрессия (англ. regression);
- Классификация (англ. classification);
Функция потерь (англ. loss function) — максимизируем вероятность того, что все объекты в обучающей выборке классифицированы правильно, вероятность - это сигмоида над значением формулы. Функция predict_proba — на выходе получаем готовые вероятности. Нужно отметить, что складывать их уже нельзя. Функция predict — выдает необработанный результат. Такой результат можно складывать, например, с результатами других моделей.
- Мультиклассификация (англ. multiclass classification);
- Ранжирование (англ. ranking).
Объекты с попарной классификацией (??)
Метрики
Поддерживает множество метрик[на 28.01.19 не создан] (англ. metrics), таких как:
- Регрессия: MAE, MAPE, RMSE, SMAPE etc.;
- Классификация: Logloss , Precision, Recall, F1, CrossEntropy, BalancedAccuracy etc.;
- Мультиклассификация: MultiClass, MultiClassOneVsAll, HammingLoss, F1 etc.;
- Ранжирование: NDCG, PrecisionAt, RecallAt, PFound, PairLogit etc.
Обучение
Шаги обучения
- Строим дерево;
- Считаем значение в листьях.
Построение дерева
Процесс построения происходит жадно.
- Выбираем первую вершину;
- Выбираем лучшее дерево с одной вершиной;
- Считаем метрику и по ней выбираем лучшее дерево.
Дерево строится по слоям. Гарантировано на каждом слое один и тот же сплит (условие по которому мы делим).
Вычисление значений в листьях
Во время вычисления значений в листьях можем позволить себе сделать больше операций, так как у нас уже зафиксирована структура дерева и значения в листьях будут вычислены единожды. Поэтому можем себе позволить даже сделать несколько шагов по градиенту или применить метод Ньютона.
Как выбрать лучшее дерево?
Смотрим, на сколько меняется функция ошибки, выбираем такое дерево, чтобы оно как можно лучше приближало вектор градиентов.
Как работает градиентный бустинг?
Отметим, что существует идеальный шаг по градиенту, однако листьев в дереве меньше, чем документов в датасете. Поэтому мы можем пытаться приближать тот самый идеальный шаг. Чтобы найти лучший сплит, проверяем похожесть после одного шага алгоритма по градиенту.
Рандомизация
Есть рандомизация метрики, по которой выбирается лучшее дерево.
Score += random_strength * Rand (0, lenofgrad * q)
q — множитель, уменьшающийся при увеличении итерации. Таким образом, рандом уменьшается ближе к концу.
Работа с датасетом
Режимов выборки данных
CatBoost поддерживает несколько режимов выборки данных
- Бутстрап (англ. bootstrap) Бернулли — выбираем документ с вероятностью p. Регулируется параметром sample_rate;
- Байесовский бутстрап — байесовское распределение. Регулируется параметром bagging_temp.
Отметим, что бутстрап используется только для выбора структуры дерева, для подсчета значения в листьях используем всю выборку. Это сделано, так как выбор структуры дерева происходит долго, нужно несколько раз пересчитывать значения, поэтому использовать всю выборку слишком дорого. Однако значения в листьях с уже готовой структурой дерева считаются один раз, и для большей точности можно позволить использовать весь датасет.
Бинаризация признаков
Пробовать все — долго. Поэтому выбираем сетку заранее и ходим по ней.
Есть несколько способов выбора:
- Uniform. Равномерно разбиваем отрезок от минимума значения для данного признака до максимума;
- Медианная сетка. Задаем количество разбиений над множеством значений, далее идем по объектам в порядке сортировки и разбиваем на группы по k объектов, где k — количество объектов в одном слоте разбиения;
- UniformAndQuantiles. Комбинация 1 и 2 пунктов;
- MaxSumLog — в основе лежит динамика, работает долго;
- GreedyLogSum — аналог MaxSumLog, используется жадный алгоритм, поэтому работает не точно, однако быстрее чем MaxSumLog.
Работа с категориальными признаками
- LabelEncoding — на реальных примерах точность работы низкая, так как появляется отношения порядка между объектами;
- One-hot encoding — дает неплохую точность, если различных значений признаков не много. Иначе один признак размножится на множество признаков и будет влиять на модель заведомо сильнее остальных признаков.
Лучше не делать препроцессинг самим из-за проблем, описанных выше. В CatBoost можно задать параметр cat_features, передав туда индексы категориальных признаков. Также можно отрегулировать параметр one_hot_max_size — максимальное количество различных значений у категориального признака, чтобы он мог в последствии быть подвержен one-hot encoding.
Подбор параметров
Ниже описаны гиперпараметры (англ. hyperparameters), на которые стоит обратить внимание при использовании библиотеки.
- cat_features;
- Overfitting detector;
- Число итераций и learning rate;
- L2_reg;
- Random_srength;
- Bagging_temp;
- Глубина дерева (стоит попробовать 10 и 6).
Полезная функциональность
- Snapshots;
- Overfitting detector;
- CV;
- eval_metrics.
Бенчмарки
Сравнение библиотеки CatBoost с открытыми аналогами XGBoost, LightGBM и H20 на наборе публичных датасетов[3].
Пример использования
- Делим данные на тренировочное и тестовое множество
from sklearn.model_selection import train_test_split
X_train, X_validation, y_train, y_validation = train_test_split(X, y, train_size=0.5, random_state=1234) print(X_train.shape, X_validation.shape)
- Создаем классификатор
from catboost import CatBoostClassifier
best_model = CatBoostClassifier( bagging_temperature=1, random_strength=1, thread_count=3, iterations=500, l2_leaf_reg = 4.0, learning_rate = 0.07521709965938336, save_snapshot=True, snapshot_file='snapshot_best.bkp', random_seed=63, od_type='Iter', od_wait=20, custom_loss=['AUC', 'Accuracy'], use_best_model=True )
- Обучаемся
best_model.fit( X_train, y_train, cat_features=cat_features, eval_set=(X_validation, y_validation), logging_level='Silent', plot=True )
- Вывод числа деревьев в модели
print('Resulting tree count:', best_model.tree_count_)
> Resulting tree count: 217
- Используем скользящий контроль (англ. cross validation)
from catboost import cv
params = best_model.get_params() params['iterations'] = 10 params['custom_loss'] = 'AUC' del params['use_best_model'] pool1 = Pool(X, label=y, cat_features=cat_features)
cv_data = cv( params = params, pool = pool1, fold_count=2, inverted=False, shuffle=True, stratified=False, partition_random_seed=0 )
- Выводим результат
best_value = np.max(cv_data['AUC_test_avg']) best_iter = np.argmax(cv_data['AUC_test_avg']) print('Best validation AUC score: {:.2f}±{:.2f} on step {}'.format( best_value, cv_data['AUC_test_stddev'][best_iter], best_iter ))
> Best validation AUC score: 0.91±0.00 on step 9
Больше примеров[4] можно найти на сайте библиотеки.
См. также
- Дерево решений и случайный леc[на 28.01.19 не создан]
- Бустинг, AdaBoost