BERT (языковая модель)
BERT (англ. Bidirectional Encoder Representations from Transformers) — языковая модель, основанная на архитектуре трансформер, предназначенная для предобучения языковых представлений с целью их последующего применения в широком спектре задач обработки естественного языка.
Содержание
Модель и архитектура
BERT представляет собой нейронную сеть, основу которой составляет композиция кодировщиков трансформера. BERT является автокодировщиком. В каждом слое кодировщика применяется двустороннее внимание, что позволяет модели учитывать контекст с обеих сторон от рассматриваемого токена, а значит, точнее определять значения токенов.
Представление данных
При подаче текста на вход сети сначала выполняется его токенизация. Токенами служат слова, доступные в словаре, или их составные части — если слово отсутствует в словаре, оно разбивается на части, которые в словаре присутствуют (см. рис. 1). Словарь является составляющей модели — так, в BERT-Base[1] используется словарь около 30,000 слов. В самой нейронной сети токены кодируются своими векторными представлениями (англ. embeddings), а именно, соединяются представления самого токена (предобученные), номера его предложения, а также позиции токена внутри своего предложения. Входные данные поступают на вход и обрабатываются сетью параллельно, а не последовательно, но информация о взаимном расположении слов в исходном предложении сохраняется, будучи включённой в позиционную часть эмбеддинга соответствующего токена.
Выходной слой основной сети имеет следующий вид: поле, отвечающее за ответ в задаче предсказания следующего предложения, а также токены в количестве, равном входному. Обратное преобразование токенов в вероятностное распределение слов осуществляется полносвязным слоем с количеством нейронов, равным числу токенов в исходном словаре.
Обучение
Предобучение
BERT обучается одновременно на двух задачах — предсказания следующего предложения (англ. next sentence prediction) и генерации пропущенного токена (англ. masked language modeling). На вход BERT подаются токенизированные пары предложений, в которых некоторые токены скрыты (см. рис. 2). Таким образом, благодаря маскированию токенов, сеть обучается глубокому двунаправленному представлению языка, учится понимать контекст предложения. Задача же предсказания следующего предложения есть задача бинарной классификации — является ли второе предложение продолжением первого. Благодаря ей сеть можно обучить различать наличие связи между предложениями в тексте.
Интерпретация этапа предобучения — обучение модели языку.
Точная настройка (Fine-tuning)
Этот этап обучения зависит от задачи, и выход сети, полученной на этапе предобучения, может использоваться как вход для решаемой задачи. Так, например, если решаем задачу построения вопросно-ответной системы, можем использовать в качестве ответа последовательность токенов, следующую за разделителем предложений. В общем случае дообучаем модель на данных, специфичных задаче: знание языка уже получено на этапе предобучения, необходима лишь коррекция сети.
Интерпретация этапа fine-tuning — обучение решению конкретной задачи при уже имеющейся общей модели языка.
Гиперпараметры
Гиперпараметрами модели являются [2] в механизме внимания.— размерность скрытого пространства кодировщика, — количество слоёв-кодировщиков, — количество голов
Данные и оценка качества
Предобучение ведётся на текстовых данных корпуса BooksCorpus[3] (800 млн. слов), а также на текстах англоязычной Википедии (2.5 млрд. слов). Качество модели авторы оценивают на популярном для обучения моделей обработки естественного языка наборе задач GLUE.[4]
Реализация
В репозитории Google Research доступны для загрузки и использования несколько вариантов обученной сети в формате контрольных точек обучения модели популярного фреймворка TensorFlow[5]. В таблице в репозитории приведено соответствие параметров и и моделей. Использование моделей с малыми значениями гиперпараметров на устройствах с меньшей вычислительной мощностью позволяет сохранять баланс между производительностью и потреблением ресурсов. Также представлены модели с различным типом скрытия токенов при обучении, доступны два варианта: скрытие слова целиком (англ. whole word masking) или скрытие составных частей слов (англ. WordPiece masking).
Также модель доступна для использования с помощью популярной библиотеки PyTorch.[6]
Пример использования
Приведём пример предказания пропущенного токена при помощи BERT в составе PyTorch. Скрытый токен — первое слово второго предложения.
# Загрузка токенизатора и входные данные tokenizer = torch.hub.load('huggingface/pytorch-transformers', 'tokenizer', 'bert-base-cased') text_1 = "Who was Jim Henson ?" text_2 = "Jim Henson was a puppeteer" # Токенизация ввода, также добавляются специальные токены начала и конца предложения. indexed_tokens = tokenizer.encode(text_1, text_2, add_special_tokens=True) segments_ids = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] # Конвертирвание ввода в формат тензоров PyTorch segments_tensors = torch.tensor([segments_ids]) tokens_tensor = torch.tensor([indexed_tokens]) encoded_layers, _ = model(tokens_tensor, token_type_ids=segments_tensors) # Выбираем токен, который будет скрыт и позднее предсказан моделью masked_index = 8 indexed_tokens[masked_index] = tokenizer.mask_token_id tokens_tensor = torch.tensor([indexed_tokens]) # Загрузка модели masked_lm_model = torch.hub.load('huggingface/pytorch-transformers', 'modelWithLMHead', 'bert-base-cased') predictions = masked_lm_model(tokens_tensor, token_type_ids=segments_tensors) # Предсказание скрытого токена predicted_index = torch.argmax(predictions[0][0], dim=1)[masked_index].item() predicted_token = tokenizer.convert_ids_to_tokens([predicted_index])[0] assert predicted_token == 'Jim'
Возможности
Преимущества
В отличие от прежних классических языковых моделей, BERT обучает контексто-зависимые представления. Например, word2vec[7] генерирует единственный эмбеддинг для одного слова, даже если слово многозначное и его смысл зависит от контекста. Использование BERT же позволяет учитывать окружающий контекст предложения, и генерировать различные эмбеддинги в таких случаях.
Контексто-зависимые модели в основном позволялют учитывать лишь левый или правый контекст токена. BERT же учитывает двусторонний контекст, что помогает модели лучше понимать смысл многозначных слов.
Применение
В 2019 году компания Google объявила об использовании BERT для анализа англоязычных поисковых запросов.[8] В конце того же года также было начато использование модели в алгоритме поиска на других языках.[9]
См. также
Примечания
-  Github — Google Research — BERT
-  Multi-Head Attention: Collaborate Instead of Concatenate
-  Aligning Books and Movies: Towards Story-like Visual Explanations by Watching Movies and Reading Books
-  GLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding
-  TensorFlow
-  PyTorch
-  word2vec
-  Google Blog — Understanding searches better than ever before
-  Search Engine Journal — Google's BERT Rolls Out Worldwide
Источники информации
- BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding — Оригинальная статья
- BERT (language model) — статья в англоязычной Википедии