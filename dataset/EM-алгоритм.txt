EM-алгоритм
Содержание
- 1 Определение
- 2 Основной алгоритм
- 3 Модификации
- 4 Пример. Разделение смеси Гауссиана
- 5 Использование в задаче кластеризации
- 6 Реализация на python
- 7 См. также
- 8 Примечания
- 9 Источники информации
Определение
Алгоритм EM (англ. expectation-maximization) — итеративный алгоритм поиска оценок максимума правдоподобия модели, в ситуации, когда она зависит от скрытых (ненаблюдаемых) переменных.
Алгоритм ищет параметры модели итеративно, каждая итерация состоит из двух шагов:
E (Expectation) шаг — поиск наиболее вероятных значений скрытых переменных.
M (Maximization) шаг — поиск наиболее вероятных значений параметров, для полученных на шаге E значений скрытых переменных.
EM алгоритм подходит для решения задач двух типов:
- Задачи с неполными данными.
- Задачи, в которых удобно вводить скрытые переменные для упрощения подсчета функции правдоподобия. Примером такой задачи может служить кластеризация.
Основной алгоритм
Постановка задачи
Плотность распределения смеси имеет вид:
.
Где — функция правдоподобия -ой компонеты смеси, — априорная вероятность -ой компоненты смеси.
Перед нами стоит две задачи:
- По заданной выборке случайных и независимых наблюдений полученных из смеси , числу и функции , оценить вектор параметров .
- Найти .
Проблема
Задачи подобного рода мы умеем решать, максимизируя логармиф правдоподобия:
.
Но проблeма в том, что мы не знаем как аналитически посчитать логарифм суммы. Тут нам и поможет алгоритм EM.
Решение
Основная идея алгоритма EM заключается в том, что мы добавляем скрытые переменные такие, что:
- Они могут быть выражены через .
- Они помогают разбить сумму так: , где — матрица скрытых переменных.
Тогда алгоритм EM сводится к повторению шагов, указанных в Определении.
E-шаг
.
Скрытые переменные представляют из себя матрицу
где — вероятность того, что пренадлежит -ой компоненте.
По формуле Байеса справедливо равенство:
.
Также
Таким образом, зная значения вектора параметров
M-шаг
|Теорема:
Если известны скрытые переменные, то задача минимизациисводится к независимым подзадачам:
Оптимальные же веса считаются как:
|Доказательство:
|
Посчитаем логарифм правдоподобия:
.
Приравняв к нулю производную Лагранжиана по
Критерий остановки
Алгоритм EM выполняется до сходимости, но как нам определить, что сходимость наступила? Мы можем останавливаться, когда либо, либо перестают сильно меняться. Но, обычно, удобней контролировать изменения значений скрытых переменных, так как они имеют смысл вероятностей и принимают значения из отрезка . Поэтому один из возможных критериев остановки будет выглядеть так: .
Псевдокод
Input:Repeat E-step: for all i = 1..m; j = 1..k: M-step: for all j = 1..k: Until a stopping criterion is satisfied Return
Плюсы и минусы
Плюсы:
- Сходится в большинтсве случаев.
- Наиболее гибкое решение.
- Существуют простые модификации, позволяющие уменьшить чуствительность алгоритма к шуму в данных.
Минусы:
- Чуствителен к начальному приближению. Могут быть ситуации, когда сойдемся к локальному экстремуму.
- Число компонент гиперпараметром. является
Модификации
Базовый алгоритм EM является очень гибким для модификаций, позволяющих улучшить его работу. В этом разделе мы приведем краткое описание некоторых из них.
Generalized EM-algorithm
Осоновная идея этой модификации заключается в том, что на шаге M мы не будем пытаться найти наилучшее решение. Это применимо в случаях, когда максимизацияявляется сликшом дорогой, поэтому нам достаточно сделать лишь несколько итераций, для того, чтобы сместиться в сторону максимума значения . Эта модификация имеет неплохую сходимость.
Stochastic EM-algorithm
Как уже было отмечено в Плюсы и минусы, базовый алгоритм чувствителен к начальному приближению и могут быть ситуации, когда алгоритм "застрянет" в локальном экстремуме. Для того, чтобы предотвратить это, будем на каждой итерации алгоритма случайно "встряхивать" выборку. В этой модификации у нас добавляется шаг S, на котором мы и будем "встряхивать" выборку. И на шаге M мы будем решать уже задачу максимуму невзвешенного правдоподобия. Эта модификация хороша тем, что нечуствиетльная к начальном приблежению.
Пример. Разделение смеси Гауссиана
Каноническим примером использования EM алгоритма является задача разделения смеси гауссиана. Данные у нас получены из нормального распределения. В этом случае параметрами функций ялвяются матожидание и дисперсия.
— вектор параметров,
— плотность распределения.
Посчитаем значения для каждого шага.
E-шаг:
M-шаг:
Использование в задаче кластеризации
Как уже упоминалось в Определении, алгоритм EM подходит для решения задачи кластеризации. И одной из его имплементаций для этой задачи является алгоритм . В этом алгоритме в качестве скрытых переменных выступают метки классов объектов. Параметрами же являются центроиды искомых классов. Тогда на шаге E мы относим объекты к какому-то одному классу на основе расстояний до центроид. А на шаге M мы пересчитываем центроиды кластеров, исходя из полученной на шаге E разметке. -Means
Также стоит упомянуть алгоритм [1]. В нем качестве скрытых переменных выступают вероятности принадлежности объекта к классам. На шаге E мы пересчитывем вероятности принадлежности объектов, иходя из расстояния до центроид. Шаг M, идейно, остается без изменений.-means
Реализация на python
В пакете sklearn алгоритм EM представлен объектом GaussianMixture. Проиллюстрируем его работу на примере задачи кластеризации и сравним его с алгоритмом-means:
import numpy as np import matplotlib.pyplot as plt from sklearn import cluster, datasets, mixture from sklearn.preprocessing import StandardScaler from itertools import cycle, islice np.random.seed(12) # Создаем datasets с использованием стандартных sklearn.datasets n_samples = 2000 random_state = 170 noisy_circles = datasets.make_circles(n_samples=n_samples, factor=.5, noise=.05) noisy_moons = datasets.make_moons(n_samples=n_samples, noise=.05) blobs = datasets.make_blobs(n_samples=n_samples, random_state=8) varied = datasets.make_blobs(n_samples=n_samples, cluster_std=[1.0, 2.5, 0.5], random_state=random_state) # Создаем анизатропно разделенные данные X, y = datasets.make_blobs(n_samples=n_samples, random_state=random_state) transformation = [[0.6, -0.6], [-0.4, 0.8]] X_aniso = np.dot(X, transformation) aniso = (X_aniso, y) # Выставляем параметры для matplotlib.pyplot plt.figure(figsize=(9 * 2 + 3, 12.5)) plt.subplots_adjust(left=.02, right=.98, bottom=.001, top=.96, wspace=.05, hspace=.01) plot_num = 1 defaul_n = 3 # Варьируем значение количества классов в зависимости от данных, ведь для нас это гиперпараметр datasets = [ (varied, defaul_n), (aniso, defaul_n), (blobs, defaul_n), (noisy_circles, 2)] for i_dataset, (dataset, n_cluster) in enumerate(datasets): X, y = dataset # Нормализация данных X = StandardScaler().fit_transform(X) # Непосредственно наш алгоритм - Gaussian Mixture gmm = mixture.GaussianMixture(n_components=n_cluster, covariance_type='full') # Для сравнения берем алгоритм - k-means two_means = cluster.KMeans(n_clusters=n_cluster) clustering_algorithms = { 'Real distribution': None, 'Gaussian Mixture': gmm, 'k-Means': two_means } for name, algorithm in clustering_algorithms: # Этап обучения if algorithm is not None: algorithm.fit(X) # Применяем алгоритм y_pred = y if algorithm is None else algorithm.predict(X) # Рисуем результаты plt.subplot(len(datasets), len(clustering_algorithms), plot_num) if i_dataset == 0: plt.title(name, size=18) colors = np.array(list(islice(cycle(['#377eb8', '#ff7f00', '#4daf4a']), int(max(y_pred) + 1)))) plt.scatter(X[:, 0], X[:, 1], s=10, color=colors[y_pred]) plt.xlim(-2.5, 2.5) plt.ylim(-2.5, 2.5) plt.xticks(()) plt.yticks(()) plot_num += 1 plt.show()
Как и следовало ожидать, алгоритм EM работает на некоторых данных лучше чем k-means, однако есть данные, с которыми он не справляется без дополнительных преобразований.
См. также
Примечания
Источники информации
- Материалы лекции про кластеризацию курса "Машинное обучение" университета ИТМО, 2019 год
- Математические методы обучения по прецедентам К. В. Воронцов
- Статья про EM-алгоритм на machinelearning.ru
- A Gentle Introduction to Expectation-Maximization
- k-means