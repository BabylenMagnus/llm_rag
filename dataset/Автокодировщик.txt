Автокодировщик
Автокодировщик (англ. autoencoder) — специальная архитектура искусственных нейронных сетей, позволяющая применять обучение без учителя при использовании метода с обратного распространения ошибки. Простейшая архитектура автокодировщика — сеть прямого распространения, без обратных связей, наиболее схожая с перцептроном и содержащая входной слой, промежуточный слой и выходной слой. В отличие от перцептрона , выходной слой автокодировщика должен содержать столько же нейронов, сколько и входной слой.
Автокодировщик состоит из двух частей: энкодераи декодера . Энкодер переводит входной сигнал в его представление (код): , а декодер восстанавливает сигнал по его коду: .
Автокодировщик, изменяяи , стремится выучить тождественную функцию , минимизируя какой-то функционал ошибки.
При этом семейства функций энкодераи декодера как-то ограничены, чтобы автоэнкодер был вынужден отбирать наиболее важные свойства сигнала.
Автокодировщик можно использовать для предобучения, например, когда стоит задача классификации, а размеченных пар слишком мало. Или для понижения размерности в данных для последующей визуализации. Либо когда просто надо научиться различать полезные свойства входного сигнала.
Содержание
- 1 Пример
- 2 Использование
- 3 Виды автокодировщиков
- 4 Пример реализации
- 5 См. также
- 6 Примечания
- 7 Источники информации
Пример
Для примера возьмем набор данных для продуктов, купленных клиентами
- Шаг 1: Возьмем первую строку из данных по клиенту для всех продуктов в качестве входа. означает, что клиент купил продукт. означает, что клиент не купил.
- Шаг 2: Закодируем ввод в другой вектор меньшего размера, чем входной. Можно использовать функцию активации сигмоида для , так как она ее область значения от до . - вес, примененный к входу, — член смещения.
- Шаг 3: Декодируем вектор , чтобы воссоздать ввод. Выход будет того же размера, что и вход
- Шаг 4: Рассчитать ошибку . Ошибка — это разница между входным и выходным вектором. Наша цель — минимизировать ошибку, чтобы выходной вектор был похож на входной вектор.
- Шаг 5: С помощью алгоритма обратного распространения ошибки нужно обновить веса. Скорость обучения определяется тем, насколько обновляются веса.
- Шаг 6: Повторите шаги с по для каждого клиента в наборе данных. Веса обновляются каждый раз (стохастический градиентный спуск)
- Шаг 7: Повторите для большего количества эпох. Эпоха - это когда все строки в наборе данных прошли через нейронную сеть.
Использование
- Нелинейное уменьшения размерности. Кодирует ввод в скрытом слое с меньшей размерностью по сравнению с входным измерением. Скрытый слой позже декодируется как выходной. Автоэнкодер уменьшает размерность линейных и нелинейных данных, следовательно, он более мощный, чем метод главных компонент[на 3.04.19 не создан].
- Рекомендации пользователям. При этом используются глубокие кодеры, чтобы понять пользовательские предпочтения, порекомендовать фильмы, книги или предметы
- Извлечения зависимостей в данных: автоэнкодеры пытаются минимизировать ошибку восстановления. В процессе уменьшения ошибки он изучает некоторые важные зависимости, присутствующие во входных данных. Он восстанавливает входные данные из кодированного состояния. Кодирование генерирует новый набор функций, который представляет собой комбинацию оригинальных зависимостей. Кодирование в автоэнкодерах помогает идентифицировать скрытые зависимости, присутствующие во входных данных.
- Распознавание изображений: для распознавания изображений используется сложный автоэнкодер. Можно использовать несколько совмещенных кодировщиков, что помогает изучить различные функции изображения.
Виды автокодировщиков
Undercomplete Autoencoders
Имеют меньший размер скрытого слоя по сравнению с входным слоем. Это помогает выделить зависимости из данных. Undercomplete Autoencoders минимизируют функцию потерь, штрафуяза отличия от входных данных x. Так же не нуждаются в регуляризации, поскольку максимизируют вероятность данных, а не копируют входные данные в выходные.
Sparse Autoencoders[1]
Размерность скрытого слоя больше, чем входного. Они все еще могут обнаружить важные особенности из данных. На скрытый слой накладывается штраф за разреженность,, значение, близкое к нулю, в дополнение к ошибке восстановления. Это предотвращает переобучение.
Denoising Autoencoders(DAE)[2]
Создаем поврежденную копию ввода, внося некоторый шум. Это помогает обучить убирать шум из данных. DAE минимизирует функцию потерь между выходным узлом и поврежденным вводом.
Contractive Autoencoders(CAE)[3]
Целью CAE является получение надежного представления данных, которое менее чувствительно к небольшим изменениям. Надежность представления данных достигается путем регуляризации. Наказание в CAE это норма Фробениуса матрицы Якоби, которая вычисляется для скрытого слоя относительно входных данных. Фробениусовой нормой матрицы Якоби является сумма квадратов всех элементов.
Stacked Denoising Autoencoders[4]
Stacked Autoencoders — это нейронная сеть с несколькими слоями Sparse Autoencoders. Когда мы добавляем в автоэнкодер больше скрытых слоев, это помогает уменьшить объемные код, получаемый кодировщиком. Restricted Boltzmann Machine (RBM) является основной частью сети глубокого убеждения.
Deep Autoencoders[5]
Состоит из двух идентичных глубоких сетей. Одна сеть для кодирования и другая для декодирования. Обычно имеют от 4 до 5 уровней для кодирования и следующие от 4 до 5 уровней для декодирования.
Вариационный автокодировщик
Автокодировщик, основанный на вариационном выводе.
Пример реализации
Ниже приведена реализация частного случая автокодировщика на языке Python с использованием библиотеки Keras. Эта реализация работает с датасетом рукописных цифр MNIST.
def create_dense_ae(): # Размерность кодированного представления encoding_dim = 49 # Энкодер # Входной плейсхолдер input_img = Input(shape=(28, 28, 1)) # 28, 28, 1 — размерности строк, столбцов, фильтров одной картинки, без батч-размерности # Вспомогательный слой решейпинга flat_img = Flatten()(input_img) # Кодированное полносвязным слоем представление encoded = Dense(encoding_dim, activation='relu')(flat_img) # Декодер # Раскодированное другим полносвязным слоем изображение input_encoded = Input(shape=(encoding_dim,)) flat_decoded = Dense(28*28, activation='sigmoid')(input_encoded) decoded = Reshape((28, 28, 1))(flat_decoded) # Модели, в конструктор первым аргументом передаются входные слои, а вторым выходные слои # Другие модели можно так же использовать как и слои encoder = Model(input_img, encoded, name="encoder") decoder = Model(input_encoded, decoded, name="decoder") autoencoder = Model(input_img, decoder(encoder(input_img)), name="autoencoder") return encoder, decoder, autoencoder
# Создание модели encoder, decoder, autoencoder = create_dense_ae() autoencoder.compile(optimizer='adam', loss='binary_crossentropy')