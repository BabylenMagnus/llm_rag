Generative Adversarial Nets (GAN)
Порождающие состязательные сети (англ. Generative Adversarial Nets, GAN) — алгоритм машинного обучения, входящий в семейство порождающих моделей и построенный на комбинации из двух нейронных сетей: генеративная модель , которая строит приближение распределения данных, и дискриминативная модель , оценивающая вероятность, что образец пришел из тренировочных данных, а не сгенерированных моделью (рис. 1). Обучение для модели заключается в максимизации вероятности ошибки дискрминатора . Впервые такие сети были представлены Иэном Гудфеллоу в 2014 году.
Содержание
- 1 Постановка задачи и метод
- 2 Интуитивный процесс тренировки
- 3 Оригинальный алгоритм обучения GAN
- 4 Проблемы обучения GAN
- 5 Применение
- 6 CGAN (Conditional Generative Adversarial Nets)
- 7 DCGAN (Deep Convolutional Generative Adversarial Nets)
- 8 StackGAN (Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks)
- 9 LAPGAN (Laplacian Pyramid of Adversarial Networks)
- 10 ControlGAN (Controllable Generative Adversarial Networks)
- 11 См. также
- 12 Примечания
- 13 Источники информации
Постановка задачи и метод
Как было указано ранее в описании метода, мы хотим обучить две модели: генеративную и дискриминативную. Поскольку, удобнее всего использовать многослойные перцептроны для обучения состязательной модели, будем использовать именно их для детального описания работы модели. Чтобы вывести вероятностное распределение генераторанад набором данных , определим априорную вероятность шума и представим генератор, как отображение , где дифференцируемая функция, представленная многослойным перцептроном с параметром . Аналогичным образом представим второй многослойный перцептрон , который на выход подает одно скалярное значение - вероятность того, что пришло из тренировочных данных, а не . Во время тренировки мы стремимся максимизировать вероятность правильной идентификации объектов из тренировочной и сгенерированной выборок. И в то же время тренируем так, чтобы минимизировать : Другими словами, и играют в "минимакс игру":
Интуитивный процесс тренировки
Как показано на рисунке 2, генеративные состязательные сети обучаются путем одновременного обновления дискриминирующего распределения (синяя пунктирная линия), так чтобы дискриминатор мог различать объекты из распределения тренировочного сета(черная пунктирная в точку линия) и из распределения генератора ( зеленая сплошная линия). Нижняя горизонтальная линия представляет собой область, из которой составлена выборка , в нашем случае равномерно. Горизонтальная линия над ней является частью области . Стрелками на картинке показано, как отображение , накладывает неравномерное распределение на тренировочное. сжимается в областях с высокой плотностью и расширяется в областях с низкой. Рассмотрим описанный на картинках процесс. (a) Близкая сходимость состязающейся пары: похоже на распределение частично-точный классификатор. (b) Во внутреннем цикле алгоритма обучается отличать объекты из тренировочных данных, сходясь к . (c) После обновления градиент привел к передвижению в область, с большей вероятностью быть классифицированным как данные. (d) После нескольких шагов обучения и придут в состояние, в котором не смогу улучшиться, так как будет выполняться условие и дискриминатор не сможет различать два распределения и его выход всегда будет .
Оригинальный алгоритм обучения GAN
В процессе обучения требуется делать два шага оптимизации поочередно: сначала обновлять веса генераторапри фиксированном , а затем веса дискриминатора при фиксированном . На практике дискриминатор обновляется раз вместо одного, поскольку, полностью оптимизировать дискриминатор вычислительно не выгодно и на конечных сетах он может переобучиться. Таким образом является гиперпараметром.
// num_iteration — число итераций обучения function GAN: for i = 1..num_iteration do for j = 1..k do //Получаем мини-батч $\{z_1, . . . , z_m\}$ из распределения $p_z$ $z$ = getBatchFromNoisePrior($p_z$) //Получаем мини-батч $\{x_1, . . . , x_m\}$ из распределения $p_{data}$ $x$ = getBatchFromDataGeneratingDistribution($p_{data}$) //Обновляем дискриминатор в сторону возрастания его градиентаend for //Получаем мини-батч $\{z_1, . . . , z_m\}$ из распределения $p_z$ $z$ = getBatchFromNoisePrior($p_z$) //Обновляем генератор в сторону убывания его градиента end for
На практике не всегда удобно использовать уравнение описанной выше. В начале обучения, когдаплохо настроен дискриминатор может не учитывать объекты, с высокой уверенностью в классификации, так как они сильно отличаются от тренировочного сета, в таком случае стагнирует. Чтобы избежать этого, можно вместо минимизации максимизировать . На рисунке 3 представлена зависимость получаемого изображения от итерации обучения.
Проблемы обучения GAN
Большинство GAN'ов подвержено следующим проблемам:
- Схлопывание мод распределения (англ. mode collapse): генератор коллапсирует, то есть выдает ограниченное количество разных образцов.
- Проблема стабильности обучения (англ. non-convergence): параметры модели дестабилизируются и не сходятся.
- Исчезающий градиент (англ. diminished gradient): дискриминатор становится слишком "сильным", а градиент генератора исчезает и обучение не происходит.
- Проблема запутывания (англ. disentanglement problem): выявление корреляции в признаках, не связанных (слабо связанных) в реальном мире.
- Высокая чувствительность к гиперпараметрам.
Часть этих проблем будет рассмотрена подробнее ниже, но нужно заметить, что универсального подхода к решению большинства из них нет. Зато существуют практические советы[1], которые могут помочь при обучении GAN'ов. Основными из них являются:
- Нормализация данных. Все признаки в диапазоне $[-1; 1]$;
- Замена функции ошибки для $G$ с $\min log (1-D)$ на $\max log D$, потому что исходный вариант имеет маленький градиент на раннем этапе обучения и большой градиент при сходимости, а предложенный наоборот;
- Сэмплирование из многомерного нормального распределения вместо равномерного;
- Использовать нормализационные слои (например, batch normalization или layer normalization) в $G$ и $D$;
- Использовать метки для данных, если они имеются, то есть обучать дискриминатор еще и классифицировать образцы.
Коллапс мод
В процессе обучения генератор может прийти к состоянию, при котором он будет всегда выдавать ограниченный набор выходов. При этом пространство, в котором распределены сгенерированные изображения, окажется существенно меньше, чем пространство исходных изображений. Главная причина этого в том, что генератор обучается обманывать дискриминатор, а не воспроизводить исходное распределение. Если генератор начинает каждый раз выдавать похожий выход, который является максимально правдоподобным для текущего дискриминатора, то зависимость от $z$ падает, а следовательно и градиент $G(z)$ стремиться к 0. Лучшей стратегией для дискриминатора будет улучшение детектирования этого конкретного изображения. Так на следующих итерациях наиболее вероятно, что генератор придет к другому изображению, хорошо обманывающему текущий дискриминатор, а дискриминатор будет учиться отличать конкретно это новое изображение. Этот процесс не будет сходиться и количество представленных мод не будет расти, поэтому приблизиться к исходному распределению не удастся. На рисунке 4 наглядно представлена проблема mode collapse и то как генератор "путешествует" по модам не приближаясь к целевому распределению. На рисунке 5 наглядно представлен пример mode collapse в процессе работы обычной GAN, обучаемой на датасете MNIST.
На текущий момент mode collape является одной из главных проблем GAN, эффективное решение которой ещё ищется. Возможные решения проблемы mode collapse:
- WGAN — использование метрики Вассерштейна (англ. Wasserstein Loss) внутри функции ошибки, позволяет дискриминатору быстрее обучаться выявлять повторяющиеся выходы, на которых стабилизируется генератор[2].
- UGAN (Unrolled GAN) — для генератора используется функция потерь, которая не только от того, как текущий дискриминатор оценивает выходы генератора, но и от выходов будущих версий дискриминатора.
Проблема стабильности обучения
Задача обучения дискриминатора и генератора в общем смысле не является задачей поиска локального или глобального минимума функции, а является задачей поиска точки равновесия двух игроков. В теории игр эта точка называется точкой равновесия Нэша (англ. Nash equilibrium) в которой оба игрока больше не получают выгоды, хотя следуют оптимальной стратегии. Рассмотрим задачу поиска этой точки на игрушечном примере, где $G$ хочет максимизировать произведение $xy$ а $D$ — минимизировать. Будем обновлять параметры $x$ и $y$ на основе градиентного спуска:Если изобразить на графике поведение $x$,$y$ и $xy$ (рис. 6) то станет ясно, что они не сойдутся, а амплитуда их движения будет только увеличиваться.
В оригинальной статье про GAN используется дивергенция Дженсена-Шеннона (англ. Jensen–Shannon divergence), которая в свою очередь использует дивергенцию Кульбака-Лейблера (англ. Kullback-Leibler divergence):
- ,
где $P$ и $Q$ — $k$-мерные абсолютно непрерывные распределения, $p(x)$ и $q(x)$ — функции плотности этих распределений, заданные на. Нетрудно заметить, что при наличии $x$, в которых $q(x)=0$, весь интеграл разойдется, что плохо влияет на сходимость обучения.
Возможные решения проблемы стабильности:
- Регуляризация — Добавление шума ко входам дискриминатора и соответствующая настройка гиперпараметров дискриминатора.
- PGGAN (Progressive Growing of GANs, разработана NVidia[3]) — в процессе работы разрешение изображений увеличивается от очень малых (4 на 4 пикселя), до конечных (1024 на 1024 пикселя), что позволяет тренировать сначала выявление крупных черт а затем более мелких, что крайне положительно сказывается на стабильности.
- WGAN — В качестве функции дивергенции используется метрика Вассерштейна, которая в большинстве случаев решает проблему расходимости интеграла в функции Дженсена-Шеннона.
Проблема запутывания (Проблема связанности характеристик)
Сложность с генеративными состязательными сетями заключается в том, что непонятно, как им удается определять конкретные различные характеристики (возраст и пол, например) и связаны ли между собой эти характеристики.
Генератор хорошо обученной сети $-$ функция [4] и FID (Frechet Inception distance[5]), где главными критериями хорошо сгенерированных образцов является разнообразие отличительных черт в образцах и их выраженность., где $-$ скрытое пространство размерности , для которого обычно применимо Гауссово распределение в многомерном случае. $-$ пространство изображений, где у каждого изображения существует набор характеристик вроде возраста или пола. Пусть нам дана функция оценки , где $-$ пространство изображений размерности . Тогда , где , $-$ связь между точкой в скрытом подпространстве и характеристиками получившегося изображения. Для функции оценок часто используют Inception score
Установлено, что при движении между двумя точкамии характеристики меняются постепенно, без скачков. Тогда по этому направлению в $Z$ можно построить гиперплоскость. Тогда сделаем предположение, при котором для любого бинарного параметра существует гиперплоскость, что все образцы с одной стороны от нее имеют одинаковое значение этого параметра.
Заведем следующую функцию "расстояния":, где , $-$ вектор нормали гиперплоскости. Данная функция не подходит под определение расстояния из-за наличия отрицательных значений (но знак нам необходим для определения знака параметра характеристики). Ожидается, что есть близкая к линеной зависимость оценки $f$ по данному параметру от "расстояния":
.
В таком случае выраженность характеристики зависит от "расстояния" до этой гиперплоскости. Аналогично происходит и в случае нескольких характеристик:
, где — диагональная матрица с линейными коэффициентами для каждой из характеристик, $-$ вектора нормалей для гиперплоскостей, разделяющих значения признаков .
В случае если— диагональная, то проблемы запутывания нет.
В противном случае проделаем манипуляции в скрытом подпространстве (рис. 7). Проецируяна и вычитая полученный вектор из , получаем такое направление в скрытом пространстве, что вдоль этих направлений у сгенерированных изображений будет изменяться характеристика $1$ вне зависимости от характеристики $2$.
При слишком большом "расстоянии" от гиперплоскости соответствующая характеристика слишком сильно делает лицо непохожим на изначальное, но это объяснимо нормальным распределением вектора шума.
Также в скрытом пространстве имеют место арифмитические операции. То есть можно складывать и вычитать вектора из этого пространства, чтобы как получать промежуточные результаты, так и убирать или добавлять какую-либо характеристику.
Для борьбы с проблемой запутывания существуют и другие подходы: один из них представляет из себя разложение изображения на передний и задний слои (с возможными промежуточными слоями)[6].
Следующий метод основан на том факте, что существуют как локальные черты, так и глобальные. К первым можно отнести форму отдельной части лица, а ко вторым $-$ возраст и пол. Иногда изменение локальной черты может очень сильно влиять на глобальную. Этого хочется избежать, для этого некоторые размерности вектора шума применяются к каждой остальной размерности[7].
Применение
Чаще всего GAN'ы используются для генерации реалистичных фотографий (рис. 8). Серьезные улучшения в этом направлении были сделаны следующими работами:
- Auxiliary GAN[8]: вариант GAN-архитектуры, использующий метки данных;
- SN-GAN[9]: GAN с новым подходом решения проблемы нестабильного обучения через спектральную нормализацию;
- SAGAN[10]: GAN, основанный на механизме внимания;
- BigGAN[11]: GAN с ортогональной регуляризацией, позволившей разрешить проблему коллапсирования при долгом обучении;
Кроме простой генерации изображений, существуют достаточно необычные применения, дающие впечатляющие результаты не только на картинках, но и на звуке:
- CycleGAN[12]: меняет изображения c одного домена на другой, например, лошадей на зебр;
- SRGAN[13]: создает изображения с высоким разрешением из более низкого разрешения;
- Pix2Pix[14]: создает изображения по семантической окраске;
- StackGAN[15]: создает изображения по заданному тексту;
- MidiNet[16]: генерирует последовательность нот, таким образом, создает мелодию.
CGAN (Conditional Generative Adversarial Nets)
Условные порождающие состязательные сети (англ. Conditional Generative Adversarial Nets, CGAN) $-$ это модифицированная версия алгоритма GAN, которая может быть сконструирована при помощи передачи дополнительных данных y, являющихся условием для генератора и дискриминатора. y может быть любой дополнительной информацией, например, меткой класса, изображением или данными из других моделей, что может позволить контролировать процесс генерации данных. Например, можно подавать параметр y, как условие на класс для генерации чисел, похожих на MNIST. Создание таких картинок, в случае передачи картинки в качетсве y является задачей трансляции изображений. Пример работы CGAN на датасете MNIST с метками классов представленных в виде one-hot векторов [17] (рис. 9).
Как уже было упомянуто на вход генератора и дискримантора из GAN подается дополнительная информация y, например в случае с многослойными перецептронами условие может быть представлено дополнительным входным слоем. (рис. 9) В генераторе априорная вероятность шума [18] В дискриминаторе x и y представлены как входные параметры.и условие комбинируются в объединённое скрытое представление, а состязательная тренирующая модель (Обе сети пытаются оптимизировать целевую функцию или функцию потерь. Когда дискриминатор меняет свое поведение, то и генератор меняет, и наоборот) предоставляет достаточно свободы в том как это представление составляется.
В таком случае задача оптимизации будет выглядеть следующим образом:
В качестве примера использования данного алгоритма можно рассмотреть задачу генерации рукописных цифр.
При создании изображения в генератор поступает скомбинированная информация двух параметров: y и вектора шума. В случае MNIST это может быть, например, просто метка класса (от 0 до 9). На выходе из генератора поступает изображение, полученное с помощью транспонированной свертки (происходит деконволюция). Затем полученное изображение комбинируется с y и поступает в дискриминатор, который в свою очередь применяет свертку, чтобы получить полносвязный слой. Наконец, анализируя полученную информацию (полносвязный слой) дискриминатор принимает решение, является ли изображение сгенерированным. (рис. 12)
Также, используя условные порождающие состязательные сети, можно научить такую сеть генерировать текст по картинке и наоборот. В качестве параметра y в данном случае передается изображение, которое будет описано (рис. 11).
Более того, для такого типа нейронных сетей, принимающих в качестве параметра у некоротое изображение местности, в результате может быть получено аналогичное изображение этого места зимой или летом, днем или ночью. Такая задача является задачей трансляции изображений.
DCGAN (Deep Convolutional Generative Adversarial Nets)
DCGAN $-$ модификация алгоритма GAN, в основе которых лежат сверточные нейронные сети (CNN). Задача поиска удобного представления признаков на больших объемах не размеченных данных является одной из наибольнее активных сфер исследований, в частности представление изображений и видио. Одним из удобных способов поиска представлений может быть DCGAN (рис. 13). Использование сверточных нейронных сетей напрямую не давало хороших результатов, поэтому было внесены ограничения на слои сверток. Эти ограничения и лежат в основе DCGAN:
- Замена всех пулинговых слоев на страйдинговые свертки (strided convolutions) в дискриминаторе и частично-страйдинговые свертки (fractional-strided-convolutions) в генераторе, что позволяет сетям находить подходящие понижения и повышения размерностей;
- Использование батчинговой нормализации для генератора и дискриминатора, то есть нормализация входа так, чтобы среднее значения было равно нулю и дисперсия была равна единице. Не стоит использовать батч-нормализация для выходного слоя генератора и входного дискриминатор.
- Удаление всех полносвязных скрытых уровней для более глубоких архитектур;
- Использование ReLU в качестве функции активации в генераторе для всех слоев, кроме последнего, где используется tanh;
- Использование LeakyReLU в качестве функции активации в дискриминаторе для всех слоев.
Помимо задачи генерации объектов, данный алгоритм хорошо показывает себя в извлечении признаков. Данный алгоритм был натренирован на наборе данных Imagenet-1k[19], после чего были использованы значения со сверточных слоев дискриминатора, подвергнутые max-pooling'у, чтобы образовать матрицы и получить общий вектор признаков на их основе. L2-SVM, c полученным представлением, на наборе данных CIFAR-10[19] превосходит по точности решения, основанные на алгоритме K-Means. Подробнее об этом вы можете прочитать в статье. [20]
StackGAN (Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks)
StackGAN $-$ порождающая состязательная сеть для генерации фото-реалистичных изображений (256x256) исходя из текстового описания. Генерировать фото-реалистичные изображения на обычных GAN сложно, поэтому была придумана двух-этапная модель генерации. Stage-I GAN рисует скетчи с примитивными формами и цветами, основанные на текстовом описании, в низком разрешении. Stage-II GAN принимает на вход изображения с первого этапа и текстовое описание и генерирует изображение в высоком разрешении с фото-реалистичными деталями. Чтобы улучшить разнообразие синтезированных изображений и стабилизировать обучение, вместо CGAN использовался метод Conditioning Augmentation.
Раннее использовались CGAN, поскольку на вход им можно было подавать условия, но просто добавляя слои, увеличивающие размер изображения, достичь хороших результатов не удалось. Поэтому основной задачей было повысить разрешение изображений.
Одной из ключевых особенностей StackGAN является Conditioning Augmentation, так как оно позволило расширить количество примеров тренировочного сета, путем небольших случайных изменений в исходных изображениях, что увеличивало многообразие данных. Как показано на картинке, текстовое описание [21].кодировщиком переводится в векторное представление (рис. 15). Раннее векторное представление нелинейно трансформировалось, чтобы получить скрытые условные переменные, которые подавались на вход генератору, однако простарнство значений скрытых переменных имеет большую размерность, что приводило к разрывам в многообразии данных, что не выгодно для генератора. Чтобы избавиться от этого как раз нужно Conditioning Augmentation, которое в отличии от предоставления фиксированных значений переменных выбирает их из нормального распределения , где среднее значение и ковариация это функции от входного вектора . В добавок к уже упомянотому, чтобы сделать многообразие гладким и не переобучиться, нужно добавить регуляризацию, (KL divergence)
Stage-I GAN тренирует дискриминатори генератор поочередной максимизицаии и минимизации , как указано в уравенинях:
Где реальное изображениеи описание текста берутся из реального распределения данных . шумовой вектор взятого случайно из нормального распределения, параметр регуляризации.
В изображениях с низким разрешенеим, сгенерированные Stage-I GAN, обычно недостает ярких деталей и могут быть искривления форм, некоторые детали изображения также могут быть опущены на первом этапе. Stage-II GAN построен над Stage-I GAN и принимает на вход его выход, и текстовое описание, чтобы исправить и дополнить изображение. Его дискриминатор и генератор тренируются путем поочередной макисимизациии минимизации , как показано в уравнениях:
Гдерезультат работы генератора Stage-I GAN и скрытый параметр подаются на вход дискриминатору и генератору Stage-II GAN, при этом на вход не подается случайное значение, как на первой стадии, поскольку хватает подачи случайного на вход Stage-I GAN. При этом Stage-I GAN и Stage-II GAN имеют разные полно-связные слои, чтобы отличаться по среднему значению и стандартному отклонению, таким образом на разных этапах фокусируюемся на разных деталях исходного текста (рис. 14).
LAPGAN (Laplacian Pyramid of Adversarial Networks)
LAPGAN $-$ генеративная параметрическая модель, представленная пирамидой лапласианов с каскадом сверточных нейронных сетей внутри, которая генерирует изображения постепенно от исходного изображения с низким разрешением к изображению с высоким. На каждом уровне пирамиды обучается сверточная генеративная модель, используя подход порождающих состязательных сетей. Такая стратегия позволяет декомпозировать задачу генерации изображений на последовательность уровней, что упрощает ее решение.
Пирамида лапласианов $-$ это линейное обратимое представление изображений, состоящее из набора частотных полос изображений. Пусть- это операция сжатия изображения размера так, что новое изображение имеет размеры , также - операция расширения такой, что имеет размеры . Тогда пирамида гаусианов имеет вид , где и представляет собой раз выполненное применение . Коэффициенты на каждом уровне пирамиды лапласианов считаются так:
Интуитивно каждый уровень захватывает структуру изображения. Конечный слой пирамиды лапласиановэто не разница изображений, а низко-частотное представление равное гаусиану . Реконструкция по пирамиде лапласианов происходит обратным проходом по ней:
Подход представленный в LAPGAN работает по такому же принципу, только на каждому шаге вместо коэфициентовиспользуются генераторы , каждый из которых захватывает распределение коэфициентов для реальных изображений на разных уровнях пирамиды лапласиана:
Процедура семплинга для нашей модели LAPGAN (рис. 16). Начинаем с шумаи используем генеративную модель для создания . Потом расширяем изображение до для следующиего уровня генерации . Вместе с еще одним шумом получаем изображение различия . Продолжаем процесс, пока не получим .
Процедура обучения LAPGAN (рис. 17). Начинаем с изображения размера из тренировчного набора. Берем и сжимаем его(красная стрелка) чтобы получить ; затем расширяем его(зеленая стрелка), чтобы получить низко-частотное изображение ; с равной вероятностью используем его для создния либо реального, либо сгенерированного примера для дискриминатора . В случае реального изображения(синяя стрелка) считаем цветовой контраст , которая подается на вход дискриминатору , для опредления реальное изображение или нет. В случае сгенерированного(розовая стрелка), генеративная сеть получает на вход шум и . Оно генерирует цветовой контраст , который подается на вход . В обоих случаях дискриминатор также получает (оранжевая стрелка). Оптимизируя минмакс игру условной порождающей сети учится генерировать реалистичную высоко-частотную структуру с помощью низко-частотного представления . Такая процедура проходит на всех слоях, кроме последнего, где можно уже использовать обычный GAN.
ControlGAN (Controllable Generative Adversarial Networks)
Контролируемые порождающие состязательные сети (англ. Controllable Generative Adversarial Nets, ControlGAN) $-$ модифицированная версия алгоритма GAN, состоящая из трех нейронных сетей: генератор, дискриминатор, классификатор. Концепт модели ControlGAN (рис. 18). Как и в обычной версии алгоритма, генератор пытается обмануть дискриминатор, и одновременно с этим пытается быть классифицированным как нужный класс в классификаторе.
Хоть CGAN и являются самыми популярными моделями для генерации образцов, зависимых от внешних данных, но лучше они умеют генерировать образцы с заданными ярко отличительными чертами (цвет волос, веснушки), но менее явные детали (форма бровей, сережки) вызывают затруднения (Но более поздний StyleGAN2 справляется и с этой задачей). C помощью отделения классификатора от дискриминатора, ControlGAN позволяет контролировать черты образцов. К тому же и само качество сгенерированных изображений может быть улучшено засчет того, что такое разделение на три составляющие дает возможность дискриминатору лучше выполнять свою главную задачу.
Более того, аугментация данных может помешать некоторым сетям, например, Auxiliary Classifier GAN (ACGAN) обучаться, хотя сам способ может улучшить качество классификации. К тому же в случае контролируемой генерации нет необходимости размечать тренировочные данные, выбираются желаемые характеристики объектов для генерации, а не условная информация (например, метка объекта).
Иллюстрация принципа работы сети (рис. 19). Зеленые линии $-$ результат работы классификатора; оранжевые $-$ дискриминатора. Серые фигуры $-$ образцы из разных классов. Результат генератора обозначается голубыми участками, которыми он показывает распределение образцов, как и пытается быть классифицированным верно.
ControlGAN минимизирует следующие уравнения:
,
,
.
$-$ метка для генератора, $-$ параметр для дискриминатора, $-$ параметр для входных меток на генератор, $-$ метки образца .
$-$ отношение между ошибками классификации сгенерированных образцов и изначальных данных. Для тренировки генератора используем оценочное значение , полученное, использующее классификатор и генератор из сети. При значении меньше $1$, генератор обучается на входных данных, иначе обучается генерировать образцы. С помощью этого параметра ControlGAN управляет, чему из вышеперечисленного обучаться. Сам параметр поддерживает постоянной отношение между ошибками.
,
,
$-$ коэффициент обучения для .
См. также
Примечания
-  How to Train a GAN? Tips and tricks to make GANs work
-  Common Problems
-  [https://research.nvidia.com/sites/default/files/pubs/2017-10_Progressive-Growing-of/karras2018iclr-paper.pdf PROGRESSIVE GROWING OF GANS FOR IMPROVED QUALITY, STABILITY, AND VARIATION]
-  Shane Barratt, Rishi Sharma — A Note on the Inception Score
-  Frechet Inception distance on Wikipedia
-  Yazeed Alharbi, Peter Wonka — Disentangled Image Generation Through Structured Noise Injection, 3.3
-  Yazeed Alharbi, Peter Wonka — Disentangled Image Generation Through Structured Noise Injection, 3.5
-  Augustus Odena — Conditional Image Synthesis with Auxiliary Classifier GANs
-  Takeru Miyato — SPECTRAL NORMALIZATION FOR GENERATIVE ADVERSARIAL NETWORKS
-  Han Zhang — Self-Attention Generative Adversarial Networks
-  Andrew Brock — LARGE SCALE GAN TRAINING FOR HIGH FIDELITY NATURAL IMAGE SYNTHESIS
-  Jun-Yan Zhu & Taesung Park — Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks
-  Christian Ledig — Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network
-  Phillip Isola — Image-to-Image Translation with Conditional Adversarial Nets
-  Han Zhang — StackGAN: Text to Photo-realistic Image Synthesis with Stacked Generative Adversarial Networks
-  Li-Chia Yang — MIDINET: A CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORK FOR SYMBOLIC-DOMAIN MUSIC GENERATION
-  CGAN
-  Yoshua Bengio, Gre `goire Mesnil, Yann Dauphin and Salah Rifai — Better Mixing via Deep Representations
-  19,0 19,1 Известные наборы данных
-  Alec Radford, Luke Metz, Soumith Chintala — Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks
-  Kullback-Leibler divergence
Источники информации
- Сергей Николенко, Артур Кадурин, Екатерина Архангельская. Глубокое обучение. Погружение в мир нейронных сетей. — «Питер», 2018. — С. 348-360.
- Medium | GAN — Why it is so hard to train Generative Adversarial Networks!
- CGAN Paper
- DCGAN Paper
- StackGAN Paper
- LAPGAN Paper
- ControlGAN Paper
- Interpreting the Latent Space Paper